import 'package:dio/dio.dart';


//attaches access token for every request using doi
//executes token rotation logic on status 401 error
//catches requests when authenticating and retries the request where authentication is invalid
//and the tracked pending requests
class AuthInterceptor extends Interceptor {
  final Future<String?> Function() getAccessToken;
  final Future<void> Function() rotateToken;
  final Dio dio;

  bool _isRefreshing = false;
  final List<_QueuedRequest> _queuedRequests = [];

  AuthInterceptor({
    required this.getAccessToken,
    required this.rotateToken,
    required this.dio,
  });

  @override
  void onRequest(RequestOptions options, RequestInterceptorHandler handler) async {
    final token = await getAccessToken();
    if (token != null) {
      options.headers['Authorization'] = 'Bearer $token';
    }
    options.extra['dio'] = dio;
    handler.next(options);
  }

  @override
  void onError(DioException err, ErrorInterceptorHandler handler) async {
    final isUnauthorized = err.response?.statusCode == 401;

    if (isUnauthorized && !_isRefreshing) {
      _isRefreshing = true;

      try {
        //rotate the token
        //the new access token generated by this should be stored in the storage
        //where the getAccessToken retrieves the data
        await rotateToken();

        //get the newly saved token
        final newToken = await getAccessToken();
        if (newToken != null) {

          // Retry all queued requests
          for (final request in _queuedRequests) {
            final updatedOptions = request.options.copyWith(
              headers: {
                ...request.options.headers,
                'Authorization': 'Bearer $newToken',
              },
            );

            try {
              final response = await request.dio.fetch(updatedOptions);
              request.handler.resolve(response);
            } catch (e) {
              request.handler.reject(e as DioException);
            }
          }

          _queuedRequests.clear();
        } else {
          handler.next(err);
        }
      } catch (_) {
        handler.next(err);
      } finally {
        _isRefreshing = false;
      }
    } else if (isUnauthorized && _isRefreshing) {
      // Queue the request while token is being refreshed
      _queuedRequests.add(
        _QueuedRequest(
          dio: err.requestOptions.extra['dio'],
          options: err.requestOptions,
          handler: handler,
        ),
      );
    } else {
      handler.next(err);
    }
  }
}

class _QueuedRequest {
  final Dio dio;
  final RequestOptions options;
  final ErrorInterceptorHandler handler;

  _QueuedRequest({
    required this.dio,
    required this.options,
    required this.handler,
  });
}
